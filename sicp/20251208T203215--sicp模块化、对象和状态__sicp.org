#+title: sicp模块化、对象和状态
#+date: [2025-12-08 一 20:32]
#+filetags: :sicp:
#+identifier: 20251208T203215

* 3.1赋值和局部状态
如果一个模型是模块化的，它就应该分解成一些计算对象，他们分别模拟系统中的一些实际对象。每一个计算对象必须有自己的一组 ~局部状态变量~ ，描述该对象的实际状态。特别的，如果我们希望用程序设计语言里常规的符号命名模拟状态变量，语言就必须提供 ~赋值操作~ ，是我们能用它修改名字的关联值。
** 3.1.1 局部状态变量
我们的语言除了允许以关键词 ~const~ 开头的常量声明以外，还需要引入 ~变量声明~ ,这种声明以关键词 ~let~ 开头。

例如：
#+BEGIN_SRC javascript
let balance = 100
#+END_SRC

与用 ~let~ 声明的名字一样，函数参数也是变量。

例如：
#+BEGIN_SRC javascript
function make_withdraw(balance) {
    return (amount) => {
		if (balance >= amount) {
			balance = balance - amount;
			return balance;
		} else {
			return "Insufficient funds";
		}
	};
}
#+END_SRC
这里的 ~balance~ 也是一个变量。

** 3.1.2 引进赋值带来的利益
通过引进赋值并把状态隐藏在局部变量中的技术，我们能以更模块化的方式遍历系统。
** 3.1.3 引进赋值的代价
不使用任何赋值的程序设计，称为 ~函数式程序设计~

*** 引进赋值破坏了引用透明性
来看下面这两个函数：
#+BEGIN_SRC javascript
function make_simplified_withdraw(balance) {
    return amount => {
               balance = balance - amount;
               return balance;
           };
}
#+END_SRC
#+BEGIN_SRC javascript
function make_decrementer(balance) {
    return amount => balance - amount;
}
#+END_SRC
第一个函数引入了赋值，第二个函数则没有引入赋值。

这两个函数的作用是完全不同的。
假设，我们有
#+BEGIN_SRC javascript
const W = make_simplified_withdraw(25)
const D = make_decrementer(25)  
#+END_SRC
这里的W和D便截然不同
#+BEGIN_SRC javascript
W(20);
5
W(10);
-5 
#+END_SRC
#+BEGIN_SRC javascript
D(20);
5
D(10);
15 
#+END_SRC
我们可以用代换模型解释 make_decrementer 的工作

#+BEGIN_SRC javascript
make_decrementer(25)(20)
#+END_SRC
#+BEGIN_SRC javascript
(amount => 25 - amount)(20)
#+END_SRC

但我们却不能对 make_simplified_withdraw 使用代换模型
#+BEGIN_SRC javascript
(amount => {
     balance = 25 - amount; 
     return 25;
 })(20)
#+END_SRC
#+BEGIN_SRC javascript
balance = 25 - 20;
return 25;
#+END_SRC
这显然错得有点可笑。

如果一个语言支持在任何表达式里“相同的东西可以互相替换”，这样替换不会改变该表达式的值，这个语言就成为具有 ~引用透明性~ 。
我们在计算机语言中引入赋值后，便破坏了引用透明性，使确定能否通过等价表达式的代换的方法简化表达式成为了一个复杂的问题。
正因此，对使用赋值的程序作推理也会成为一个复杂的问题。

*** 命令式程序设计的缺陷
与函数式程序设计对应，广泛使用赋值的程序设计被称为 ~命令式程序设计~

一般而言，使用赋值的程序设计迫使我们去考虑赋值前后的问题，以保证每个语句用的都是被修改变量的正确版本。这类问题不会出现在函数式程序里。
如果我们考虑存在多个并发执行的进程的应用程序，命令式程序设计的复杂性还会更糟。
* 3.2 求值的环境模型
在我们的求值模型里，一个名字必须以某种方式指定一个“位置”，在那里可以储存值，这种位置维持在一种称为 ~环境~ 的结构里。
环境是框架（frame）的序列，每个框架是包含着一些 ~约束~ 的表格（可能为空)，这些约束把一些名字关联于对应的值（在一个框架里，任何变量至多只能有一个约束）。
每个框架包含一个指针，指向该框架的 ~外围环境~ ，除非该框架在当前讨论中被当成 ~全局的~ 。
一个名字的值（相对于某个特定环境），就是在相应环境里的第一个包含这个名字的约束的框架里，该名字的约束值。如果在环境的框架序列中不存在这个名字的约束，我们说这个名字在该特定环境中 ~未约束~

如图，下图中有三个框架，分别记作I,II,III。A,B,C,D分别为环境指针（C和D指向同一个环境）。变量z和x在框架II中约束，变量x和y在框架I中约束。也就是说x在B,C和D环境中的值都是3。（关于B环境中x的值为3,按照下面的方式确定：首先检查序列中的第一个框架（框架III），在这里没有找到x的约束，因此继续前进，到这个框架的外围环境D并在环境I中找到相应约束）最后，x在环境A中的值是7,因为在序列中的第一个框架就找到了x与7的约束。相对于环境A,我们说在框架II里x与7的约束 ~遮蔽~ 了框架I中x与3
的约束。
 [[./sicp_pic/ch3-Z-G-2.svg]]

在求值一个程序前我们给全局环境扩充一个框架，成为 ~程序框架~ ，得到的环境成为 ~程序环境~ 。我们把所有在程序顶层（也就是任何块结构之外）声明的名字加入程序环境，
** 3.2.1 求值规则
求值一个函数应用式时，按下面的方式工作
1. 求值应用式中的各个子表达式，即其中的函数表达式和各个实参表达式。
2. 把得到的函数（也就是函数表达式的值）应用于那些实参表达式的值

在求值的环境模型里， _一个函数是一个序对，由一些代码和一个指向环境的指针构成。函数只有一种创建方式，就是通过求值lambda表达式。这样生成的函数，代码来自lambda表达式的正文，其环境就是求值该lambda表达式从而生成该函数时的那个环境_

例如：
#+begin_src javascript
function square(x) {
    return x * x;
}
#+end_src
等价于
#+begin_src javascript
const square = x => x * x; 
#+end_src

如下图：
下图描绘了这个语句求值后的情况。全局环境包围着程序环境。（另外，在sicp书中，以后将不再画出全局环境）
函数对象是一个序对，其代码部分说明这个函数由一个形式参数x,其函数体是 ~return x * x;~ 。函数的环境部分是一个指向程序环境的指针，因为产生这个函数的lambda表达式是在程序框架中求值的。这个声明的求值在程序框架里加入一个新约束，把生成的函数对象约束于名字square。
[[./sicp_pic/sicp3.2.1-p3.2.png]]

一般而言， ~const~ ~let~ ~function~ 都会在框架里加入约束 我们用符号 ~:=~ 表示常量。函数声明等价于常量声明。

如下图：
下图描绘了函数的应用。（即求值 ~square(5)~ ）时创建的环境结构。该函数创建了一个新环境，用E1表示。该环境从一个框架开始，其中包含函数的形式参数x到实际参数5
的约束。（形式参数被当作变量看待）。该框架的外围环境是程序环境。因为它是作为square函数对象的那个环境。我们在E1中求值函数体 ~return x * x~ 。求值的结果是25。
[[./sicp_pic/sicp3.2.1-p3.3.png]]
** 3.2.2 简单函数应用
使用环境模型分析下面的实例：
#+begin_src javascript
function square(x) {
    return x * x;
}
function sum_of_squares(x, y) {
    return square(x) + square(y);
}
function f(a) {
    return sum_of_squares(a + 1, a * 2);
} 
#+end_src
如下图：
下图描绘了在程序环境中对 ~f~ ~squaare~ ~sum_of_squares~ 的声明的求值完成时创建的三个函数对象，每个对象由一些代码和一个指向环境的指针构成。
[[./sicp_pic/sicp3.2.2-p3.4.png]]

下图描绘的是求值 ~f(5)~ 时创建的环境结构。可以看到，每当我们把实参应用于函数时，都会创建一个新的框架
这里的重点是，对square的每个调用都会创建一个新的框架，这告诉我们，每当实参应用于函数时，都会创造一个新的框架，即便它们应用于同一个函数。通过创建不同的框架，我们才能够做到维持所有名字为x的局部变量不相同。
[[./sicp_pic/sicp3.2.2-p3.5.png]]

** 3.2.3 框架作为局部状态的仓库
有以下代码：
#+begin_src javascript
function make_withdraw(balance) {
    return amount => {
               if (balance >= amount) {
                   balance = balance - amount;
                   return balance;
               } else {
                   return "insufficient funds";
               }
           };
} 
#+end_src
#+begin_src javascript
const W1 = make_withdraw(100); 
#+end_src
#+begin_src javascript
W1(50); 
50
#+end_src

如下图，描绘了在程序里声明 make_withdraw函数的结果。
[[./sicp_pic/sicp3.2.3-p3.6.png]]

这个计算和以往的不同之处会出现在把函数 make_withdraw 应用于参数的时候
#+begin_src javascript
const W1 = make_withdraw(100); 
#+end_src
和以往一样，我们会在把实参100应用于函数 make_withdraw 时设置环境E1,其中形参balance约束到实参100,并在这个环境里求值 make_withdraw 的体，也就是那个返回语句，即一个lambda表达式。求值该lambda表达式会构造出一个新的函数对象，其代码来自lambda表达式，而其环境是E1,并不是程序环境。这个函数对象是调用 make_withdraw 的返回值，它在程序环境里约束于W1,因为对常量声明的求值本身实在程序环境里进行的。
下图显示了这些处理完成后得到的环境结构
[[./sicp_pic/sicp3.2.3-p3.7.png]]

接下来分析把W1应用于一个实参时出现的情况：
#+begin_src javascript
W1(50); 
50
#+end_src
同样的，把函数应用于实参时应该要创建新的框架，将W1的形式参数amount在其中约束到实参50。这里的关键点是：这个框架的外围环境不是程序环境，而是环境E1,因为它才是函数对象W1指定的环境。

得到的环境如下图所示:

[[./sicp_pic/sicp3.2.3-p3.8.png]]

执行赋值就修改了balance在E1的约束。在对W1的调用完成时balance的值是50,而且包含着这个balance的框架仍然被W1的函数对象约束着。约束amount的那个框架则无关紧要了，构造它的函数调用已经结束，环境中任何部分都不包含指向该框架的指针了。下一次W1被调用时，这个函数又会构造一个新框架，在其中建立amount的新的约束。

下图是调用W1后得到情景：

[[./sicp_pic/sicp3.2.3-p3.9.png]]

接下来看一下再次调用 make_withdraw创建第二个对象会出现什么。
#+begin_src javascript
const W2 = make_withdraw(100); 
#+end_src

这个语句产生的环境结构当如下图所示，其中的W2也是一个函数对象，也就是说，是一些代码和一个环境的序对，它包含一个框架，其中有它自己对balance的局部约束。另一方面，W1和W2的代码相同，也就是 make_withdraw 体内那个lambda表达式的代码。在这里我们看到了为什么W1和W2是行为上完全独立的两个对象。调用W1引用的是E1对象中的balance,W2则是E2对象中的balance
[[./sicp_pic/sicp3.2.3-p3.10.png]]
** 3.2.4 内部定义
这一节，将讨论包含声明的函数体或其他块结构（例如条件语句的分支）的求值问题。每个块结构为块中声明的名字开辟了一个新作用域。为了在给定的环境中求值块结构，我们需要扩充这个环境，增加一个框架，其中包含所有直接在这个块体里（也就是说，在其内部嵌套的块之外）声明得到名字，然后在这个新环境中求值块体。

有下面的代码
#+begin_src javascript
function sqrt(x) {
    function is_good_enough(guess) {
        return abs(square(guess) - x) < 0.001;
    }
    function improve(guess) {
        return average(guess, x / guess);
    }
    function sqrt_iter(guess){
        return is_good_enough(guess)
               ? guess
               : sqrt_iter(improve(guess));
    }
    return sqrt_iter(1);
} 
#+end_src

如下图（该图像为了简洁，只画了约束于 is_good_enough 的函数对象）：
观察这个环境结构。名字sqrt在程序环境里约束到一个函数对象，与之关联的就是程序环境。sqrt被调用时生成一个新环境E1,作为程序环境的下属，参数x在其中约束到2。然后sqrt的体在E1里求值。这个函数体是一个块，其中包含局部的函数声明。因此E1就会被扩充，为求值块里的代码创造一个新框架，由此得到新环境E2。下一步就是在E2里求值这个块里的代码。块体里需要求值的第一个语句是：
#+begin_src javascript
function is_good_enough(guess) {
    return abs(square(guess) - x) < 0.001;
}
#+end_src
求值这个声明在环境E2里创建函数 is_good_enough 。improve 和 sqrt_iter 也类似。

定义好各个局部函数之后，现在要求值表达式 sqrt_iter(1) ，还是在环境E2中。这个调用创建了另一个新环境 E3，其中 sqrt_iter 的形参guess约束到1。函数 sqrt_iter 转而以 guess 的值作为实参调用 is_good_enough ，这是创建了另一个E4,（is_good_enough的形参）guess在该环境里约束到1。虽然 sqrt_iter 和 is_good_enough 都有名字作为guess的形参，但它们是两个不同的局部变量，位于不同的框架里。还有，E3和E4都以E2作为其外围环境，这是因为函数 sqrt_iter 和 is_good_enough 都以E2作为自己的定义环境。这种情况造成的一个后果就是，出现在 is_good_enough 体内部的名字x将引用出现在E1里的x约束
[[./sicp_pic/sicp3.2.4-p3.11.png]]

局部函数声明是程序模块化的有用技术，环境模型解释了这种技术所具有的两个关键性质。
- 局部函数的名字不会与包含它们的函数之外的名字互相干扰，这是因为这些局部函数名都是在该函数求值时创建的框架里约束的，而不是在程序环境里约束的。
- 局部函数可以访问包含着它们的函数的参数（以及在那里局部声明的变量和常量）。如果希望这样，只需将相应的形参的名字作为自由名字。这是因为，对局部函数的体求值时所使用的环境是其外围函数求值时所用的环境的下属
* 3.3 用变动数据建模
在sicp的第二章，介绍了数据抽象的系统方法，按这种方法，数据结构应该用构造函数（用于创建数据对象）和选择函数（用于访问复合数据对象中的部分）描述。
但是，为了模拟不断变化的复合对象，我们设计的数据抽象不但要包含选择函数和构造函数，还应包含一种 *变动函数* ，用于修改相应的数据对象。定义了变动函数的数据对象称为 *可变数据对象*
** 3.3.1 可变的表结构
在sicp的第二章，介绍了序对这一数据结构。
这里介绍了操作序对的基本变动函数 ~set_head~ 和 ~set_tail~
~set_head~ 要求两个参数，其第一个参数必须是序对。 ~set_head~ 修改这个序对，把它的head指针替换为指向 set_head 的第二个参数的指针。

例子如下：x约束到表list(list("a", "b"), "c", "d")，y约束到list("e", "f")。
求值函数 set_head(x, y)的操作结果如下图所示，它将修改x约束的那个序对，把它的head用y值取代。
此时的x等价于 list(list("e", "f"), "c", "d")
[[./sicp_pic/sicp3.3.1-p3.12.png]]
[[./sicp_pic/sicp3.3.1-p3.13.png]]

下面展示的是执行 ~const z = pair(y, tail(x));~ 的结果。执行该操作后，名字z约束到了由pair操作创建的一个新序对，而x的约束没有改变
[[./sicp_pic/sicp3.3.1-p3.14.png]]

~set_tail~ 操作与 ~set_head~ 类似，不同点在于它只对tail指针工作。对最开始的例子使用 ~set_tail(x, y)~ 其结果当如下图所示
[[./sicp_pic/sicp3.3.1-p3.15.png]]

pair也可以用一两个变动函数和一个返回新序对的函数 get_new_pair 实现，这里得到的新序对不是任何表结构的组成部分。
#+begin_src javascript
function pair(x, y) {
    const fresh = get_new_pair();
    set_head(fresh, x);
    set_tail(fresh, y);
    return fresh;
} 
#+end_src
** 3.3.2 队列的表示
这一节将展示如何使用序列表示一种称为队列的结构

队列是我们所熟知的一种“FIFO”的结构
队列操作如下图所示：
[[./sicp_pic/sicp3.3.2-p3.18.png]]

依照数据抽象的说法，队列可以看作是由下面一组操作定义的结构：
- 一个构造函数：
#+begin_src javascript
make_queue()
#+end_src
它返回一个空队列（不包含数据项的队列）
- 一个谓词
#+begin_src javascript
is_empty_queue(queue)
#+end_src
检查队列queue是否为空
- 一个选择函数
#+begin_src javascript
front_queue(queue)
#+end_src
返回队列前端queue的对象，如果为空则报错。它不修改队列。
- 两个变动函数
#+begin_src javascript
insert_queue(queue, item)
#+end_src
将数据项item插入队列queue的尾端，返回修改过的队列的值
#+begin_src javascript
delete_queue(queue)
#+end_src
删除队列queue前端的数据项并返回修改后的队列的值。如果queue为空则报错

我们可以把队列视作一个常规的表。对列前端就是表的head,向队列中插入项就是把项附到表的最后，而从队列里删除项就是取表的tail。但是这种做法非常低效，为了插入项，我们必须扫描表达到表尾。扫描表只能进行一系列tail操作，对n个项的表，这种扫描就要进行 theta(n) 步 。不过，可以通过修改一下表的表示方式，使各种队列操作只需要 theta(1) 步。

修改的方法是仍然将队列表示为表，但增加一个指向表中最后序对的指针。这样插入项时就可以通过表尾指针，避免了对表的扫描。
这样，一个队列将用指针 front_ptr 和 reaar_ptr 表示，它们分别指向一个常规表中的第一个和最后一个序对。
因为我们希望队列成为可标识对象，所以我们用pair组合这两个指针。这样，队列本身就是两个指针的pair。
如下图所示：
[[./sicp_pic/sicp3.3.2-p3.19.png]]

为了实现队列操作，我们先声明以下函数，它们使我们可以选择和修改队列的前端和尾端指针。
#+begin_src javascript
function front_ptr(queue) { return head(queue); }

function rear_ptr(queue) { return tail(queue); }

function set_front_ptr(queue, item) { set_head(queue, item); }

function set_rear_ptr(queue, item) { set_tail(queue, item); } 
#+end_src
接下来的代码都很好理解
#+begin_src javascript
function is_empty_queue(queue) { return is_null(front_ptr(queue)); } 
#+end_src
如果一个队列的前端指针是空表，我们就认为这个队列是空的。

#+begin_src javascript
function make_queue() { return pair(null, null); } 
#+end_src
make_queue返回一个空队列，也就是一个序对，其head和tail都是空表

#+begin_src javascript
function front_queue(queue) {
    return is_empty_queue(queue)
           ? error(queue, "front_queue called with an empty queue")
           : head(front_ptr(queue));
} 
#+end_src
选取队列的前端项时，我们返回由前端指针指向的序对的head

向队列中插入一个项的时，我们参考下图所示的方法
#+begin_src javascript
function insert_queue(queue, item) {
    const new_pair = pair(item, null);
    if (is_empty_queue(queue)) {
        set_front_ptr(queue, new_pair);
        set_rear_ptr(queue, new_pair);
    } else {
        set_tail(rear_ptr(queue), new_pair);
        set_rear_ptr(queue, new_pair);
    }
    return queue;
} 
#+end_src
[[./sicp_pic/sicp3.3.2-p3.20.png]]

#+begin_src javascript
function delete_queue(queue) {
    if (is_empty_queue(queue)) {
        error(queue, "delete_queue called with an empty queue");
    } else {
        set_front_ptr(queue, tail(front_ptr(queue)));
        return queue;
    }
} 
#+end_src
在队列中删除项的方法，可以参考下图：
[[./sicp_pic/sicp3.3.2-p3.21.png]]

补充：
有关 front_ptr(queue) 的值一直在改变，尽管看起来 insert_queue 的代码在对列不为空之后再也没有修改过它。然而，要知道，最开始对 set_front_ptr 和 set_rear_ptr 函数执行时，它们实际上是同一个 pair 所以后来对 set_tail 的执行，实际上也修改了 front_ptr(queue) 因为它们在环境中绑定的是同一个 pair
#+begin_src javascript
function insert_queue(queue, item) {
    const new_pair = pair(item, null);
    if (is_empty_queue(queue)) {
        set_front_ptr(queue, new_pair);
        set_rear_ptr(queue, new_pair);
    } else {
        set_tail(rear_ptr(queue), new_pair);
        set_rear_ptr(queue, new_pair);
    }
    return queue;
} 
#+end_src
** 3.3.3 表格的表示
*** 一维表格
我们先考虑一维表格，这种表格里的每一个值保存在一个关键码之下。
我们要把这种表格实现为记录的表，每个记录实现为由关键码和其关联值组成的序对。我们用记录把序对连接起来构成表，让这些序对的head指针指向顺序的各个记录。作为连接结构的那些序对称为表格的 *骨架* 。为了在给表格里加入记录时总有可以修改的位置，我们把这种表格构造为一种带 *带表头的表* 。这种表开头由一个特殊的骨架序对，其中保存一个哑记录————我们存入一个任意选定的字符串 ="**table**"=
#+begin_src
a: 1
b: 2
c: 3
#+end_src

下图为该表格的盒子指针图：
[[./sicp_pic/sicp3.3.3-p3.22.png]]

下面是构造表格的相关代码
#+begin_src javascript
function lookup(key, table) {
    const record = assoc(key, tail(table));
    return is_undefined(record)
           ? undefined
           : tail(record);
}
function assoc(key, records) {
    return is_null(records)
           ? undefined
           : equal(key, head(head(records)))
           ? head(records)
           : assoc(key, tail(records));
} 
#+end_src
关于为什么是 ~assoc(key, tail(table));~ 是因为assoc不应该查看表格的哑记录，那是没有意义的。
这样， lookup 函数就实现了表格的查找功能。

下面是表的插入功能
#+begin_src javascript
function insert(key, value, table) {
    const record = assoc(key, tail(table));
    if (is_undefined(record)) {
        set_tail(table,
                 pair(pair(key, value), tail(table)));
    } else {
        set_tail(record, value);
    }
    return "ok";
} 
#+end_src
如果没有关键码和相关值，则创造一个新记录，如果已经存在具有这个关键码的记录，就把该记录的tail设为新值。

构造表格时，只需要创建一个包含字符串 ="**table**"= 的表。
#+begin_src javascript
function make_table() {
    return list("*table*");
} 
#+end_src

*** 二维表格
下面是一个二维表格的实例：
#+BEGIN_SRC
"math":
    "+":  43
    "-":  45
    "*":  42
"letters":
    "a":  97
    "b":  98
#+end_src

下面的是盒子指针图：
[[./sicp_pic/sicp3.3.3-p3.23.png]]
